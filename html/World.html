<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>World API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>World</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
import json
import math
import operator
import re
import time
from functools import reduce


def get_location(nested_dict=None, keys_list=None):
    &#34;&#34;&#34;
    Description
    -----------
    Static function to get a value of a nested key from a nested dictionary
    :param nested_dict: Nested dictionary from which the nested value is to be retrieved
    :param keys_list: The verbose keys corresponding to the desired value being passed in
                     as a python list of list
    :return: The expected value corresponding to the provided nested keys
    &#34;&#34;&#34;
    if keys_list is None:
        keys_list = []
    if nested_dict is None:
        nested_dict = {}
    return reduce(operator.getitem, keys_list, nested_dict)


def update_crops(nested_dict=None, keys_list=None, crop=&#34;CARROTS&#34;):
    &#34;&#34;&#34;
    Description
    -----------
    Static function to update a value of a nested key in a nested dictionary
    :param crop: The name of the crop that is to be planted in the specific location
    :param nested_dict: Nested dictionary in which the nested value is to be updated
    :param keys_list: The verbose keys corresponding to the desired value being passed in
                     as a python list of list
    &#34;&#34;&#34;
    if keys_list is None:
        keys_list = []
    if nested_dict is None:
        nested_dict = {}
    get_location(nested_dict, keys_list[:-1])[keys_list[-1]] = crop


class Farm:
    def __init__(self):
        &#34;&#34;&#34;
        Description
        -----------
        Function to load a json farm map to a nested dictionary. The file is repeatedly attempted to
        be opened and loaded if the file does not exist in the given location. The initializer function
        also calculates the lengths of all paths and fields using the data available in the predefined
        farm map. The lengths of irregular paths are calculated using the euclidean distance formula
        &#34;&#34;&#34;
        self.json_path = &#39;&#39;
        status = 0
        while status == 0:
            try:
                self.json_path = input(&#34;Please enter the world file path : &#34;)
                with open(self.json_path) as json_file:
                    self.data = json.load(json_file)
            except:
                print(&#34;The said world file does not exist. Please enter a valid path again&#34;)
            else:
                status = 1

        # Calculate the lengths of paths
        self.field_a_length = self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-a&#39;][&#39;rows&#39;][&#39;row-00&#39;][&#39;location&#39;][1] - \
                              self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-a&#39;][&#39;rows&#39;][&#39;row-19&#39;][&#39;location&#39;][1]
        self.row_spacing_field_a = self.field_a_length / 19
        self.field_b_length = self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-b&#39;][&#39;rows&#39;][&#39;row-00&#39;][&#39;location&#39;][1] - \
                              self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-b&#39;][&#39;rows&#39;][&#39;row-19&#39;][&#39;location&#39;][1]
        self.row_spacing_field_b = self.field_b_length / 19
        self.path_lengths = []

        for path in self.data[&#39;world&#39;][&#39;paths&#39;].items():
            self.path_lengths.append(
                10 * math.sqrt((math.pow(path[1][&#39;waypoint-0&#39;][0] - path[1][&#39;waypoint-1&#39;][0], 2)) +
                               (math.pow(path[1][&#39;waypoint-0&#39;][1] - path[1][&#39;waypoint-1&#39;][1], 2))))

    def decrypt_location(self, location=&#34;Charger&#34;):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to return the exact location coordinates of a specific location of the robot based
        on path waypoint numbers and row numbers in the two given fields
        :param location: The location of the robot in the form of a string. Example: Charger, FBR10, etc.
        :return: The location coordinates as a string. Example: [300, 500], [1000, 50], etc.
        &#34;&#34;&#34;
        if re.match(r&#39;(\s)*charger(\s)*&#39;, location, re.IGNORECASE):
            return &#34;[charger]&#34;, self.data[&#39;world&#39;][&#39;charger&#39;][&#39;location&#39;]
        elif re.match(r&#39;(\s)*PTH(\s)*\d+&#39;, location, re.IGNORECASE):
            output = (re.findall(r&#39;\d+&#39;, location))
            path_number = int(output[0])
            waypoint_number = int(output[1])
            location_key = [&#34;world&#34;, &#34;paths&#34;, &#34;path-&#34; + str(path_number), &#34;waypoint-&#34; + str(waypoint_number)]
            return &#34;[path-&#34; + str(path_number) + &#34;]&#34;, get_location(self.data, location_key)
        else:
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            location_key = [&#34;world&#34;, &#34;fields&#34;,
                            &#34;field-b&#34; if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE) else &#34;field-a&#34;, &#34;rows&#34;,
                            &#34;row-&#34; + str(output), &#34;location&#34;]
            return &#34;[&#34; + str(location_key[2]) + &#34;]&#34; + &#34;[&#34; + str(location_key[4]) + &#34;]&#34;, get_location(self.data,
                                                                                                     location_key)

    def update_world(self, location=&#34;FBR8&#34;, crop=&#34;CARROTS&#34;):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to plant a crop in the farm file at the desired field and row location
        :param location: An encoded name of the field and row location passed in as a string
        :param crop: The name of the crop to be planted passed in as a string
        &#34;&#34;&#34;
        if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE):
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-b&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
            update_crops(self.data, crop_key, crop)
        else:
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-a&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
            update_crops(self.data, crop_key, crop)

    def write_to_world_file(self):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to write the current farm file to the given json file. The function simply opens the json
        file which is initialized by the __init__ function and then writes the stored dictionary to the file and
        closes it
        &#34;&#34;&#34;
        with open(self.json_path, &#34;w+&#34;) as world_file:
            world_file.write(json.dumps(self.data))


if __name__ == &#39;__main__&#39;:
    start = time.time()
    print(Farm().decrypt_location())
    end = time.time()
    time_taken = end - start
    print(&#39;Time: &#39;, time_taken)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="World.get_location"><code class="name flex">
<span>def <span class="ident">get_location</span></span>(<span>nested_dict=None, keys_list=None)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Static function to get a value of a nested key from a nested dictionary
:param nested_dict: Nested dictionary from which the nested value is to be retrieved
:param keys_list: The verbose keys corresponding to the desired value being passed in
as a python list of list
:return: The expected value corresponding to the provided nested keys</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location(nested_dict=None, keys_list=None):
    &#34;&#34;&#34;
    Description
    -----------
    Static function to get a value of a nested key from a nested dictionary
    :param nested_dict: Nested dictionary from which the nested value is to be retrieved
    :param keys_list: The verbose keys corresponding to the desired value being passed in
                     as a python list of list
    :return: The expected value corresponding to the provided nested keys
    &#34;&#34;&#34;
    if keys_list is None:
        keys_list = []
    if nested_dict is None:
        nested_dict = {}
    return reduce(operator.getitem, keys_list, nested_dict)</code></pre>
</details>
</dd>
<dt id="World.update_crops"><code class="name flex">
<span>def <span class="ident">update_crops</span></span>(<span>nested_dict=None, keys_list=None, crop='CARROTS')</span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Static function to update a value of a nested key in a nested dictionary
:param crop: The name of the crop that is to be planted in the specific location
:param nested_dict: Nested dictionary in which the nested value is to be updated
:param keys_list: The verbose keys corresponding to the desired value being passed in
as a python list of list</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_crops(nested_dict=None, keys_list=None, crop=&#34;CARROTS&#34;):
    &#34;&#34;&#34;
    Description
    -----------
    Static function to update a value of a nested key in a nested dictionary
    :param crop: The name of the crop that is to be planted in the specific location
    :param nested_dict: Nested dictionary in which the nested value is to be updated
    :param keys_list: The verbose keys corresponding to the desired value being passed in
                     as a python list of list
    &#34;&#34;&#34;
    if keys_list is None:
        keys_list = []
    if nested_dict is None:
        nested_dict = {}
    get_location(nested_dict, keys_list[:-1])[keys_list[-1]] = crop</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="World.Farm"><code class="flex name class">
<span>class <span class="ident">Farm</span></span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Function to load a json farm map to a nested dictionary. The file is repeatedly attempted to
be opened and loaded if the file does not exist in the given location. The initializer function
also calculates the lengths of all paths and fields using the data available in the predefined
farm map. The lengths of irregular paths are calculated using the euclidean distance formula</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Farm:
    def __init__(self):
        &#34;&#34;&#34;
        Description
        -----------
        Function to load a json farm map to a nested dictionary. The file is repeatedly attempted to
        be opened and loaded if the file does not exist in the given location. The initializer function
        also calculates the lengths of all paths and fields using the data available in the predefined
        farm map. The lengths of irregular paths are calculated using the euclidean distance formula
        &#34;&#34;&#34;
        self.json_path = &#39;&#39;
        status = 0
        while status == 0:
            try:
                self.json_path = input(&#34;Please enter the world file path : &#34;)
                with open(self.json_path) as json_file:
                    self.data = json.load(json_file)
            except:
                print(&#34;The said world file does not exist. Please enter a valid path again&#34;)
            else:
                status = 1

        # Calculate the lengths of paths
        self.field_a_length = self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-a&#39;][&#39;rows&#39;][&#39;row-00&#39;][&#39;location&#39;][1] - \
                              self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-a&#39;][&#39;rows&#39;][&#39;row-19&#39;][&#39;location&#39;][1]
        self.row_spacing_field_a = self.field_a_length / 19
        self.field_b_length = self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-b&#39;][&#39;rows&#39;][&#39;row-00&#39;][&#39;location&#39;][1] - \
                              self.data[&#39;world&#39;][&#39;fields&#39;][&#39;field-b&#39;][&#39;rows&#39;][&#39;row-19&#39;][&#39;location&#39;][1]
        self.row_spacing_field_b = self.field_b_length / 19
        self.path_lengths = []

        for path in self.data[&#39;world&#39;][&#39;paths&#39;].items():
            self.path_lengths.append(
                10 * math.sqrt((math.pow(path[1][&#39;waypoint-0&#39;][0] - path[1][&#39;waypoint-1&#39;][0], 2)) +
                               (math.pow(path[1][&#39;waypoint-0&#39;][1] - path[1][&#39;waypoint-1&#39;][1], 2))))

    def decrypt_location(self, location=&#34;Charger&#34;):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to return the exact location coordinates of a specific location of the robot based
        on path waypoint numbers and row numbers in the two given fields
        :param location: The location of the robot in the form of a string. Example: Charger, FBR10, etc.
        :return: The location coordinates as a string. Example: [300, 500], [1000, 50], etc.
        &#34;&#34;&#34;
        if re.match(r&#39;(\s)*charger(\s)*&#39;, location, re.IGNORECASE):
            return &#34;[charger]&#34;, self.data[&#39;world&#39;][&#39;charger&#39;][&#39;location&#39;]
        elif re.match(r&#39;(\s)*PTH(\s)*\d+&#39;, location, re.IGNORECASE):
            output = (re.findall(r&#39;\d+&#39;, location))
            path_number = int(output[0])
            waypoint_number = int(output[1])
            location_key = [&#34;world&#34;, &#34;paths&#34;, &#34;path-&#34; + str(path_number), &#34;waypoint-&#34; + str(waypoint_number)]
            return &#34;[path-&#34; + str(path_number) + &#34;]&#34;, get_location(self.data, location_key)
        else:
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            location_key = [&#34;world&#34;, &#34;fields&#34;,
                            &#34;field-b&#34; if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE) else &#34;field-a&#34;, &#34;rows&#34;,
                            &#34;row-&#34; + str(output), &#34;location&#34;]
            return &#34;[&#34; + str(location_key[2]) + &#34;]&#34; + &#34;[&#34; + str(location_key[4]) + &#34;]&#34;, get_location(self.data,
                                                                                                     location_key)

    def update_world(self, location=&#34;FBR8&#34;, crop=&#34;CARROTS&#34;):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to plant a crop in the farm file at the desired field and row location
        :param location: An encoded name of the field and row location passed in as a string
        :param crop: The name of the crop to be planted passed in as a string
        &#34;&#34;&#34;
        if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE):
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-b&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
            update_crops(self.data, crop_key, crop)
        else:
            output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
            crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-a&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
            update_crops(self.data, crop_key, crop)

    def write_to_world_file(self):
        &#34;&#34;&#34;
        Description
        -----------
        Member function to write the current farm file to the given json file. The function simply opens the json
        file which is initialized by the __init__ function and then writes the stored dictionary to the file and
        closes it
        &#34;&#34;&#34;
        with open(self.json_path, &#34;w+&#34;) as world_file:
            world_file.write(json.dumps(self.data))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="World.Farm.decrypt_location"><code class="name flex">
<span>def <span class="ident">decrypt_location</span></span>(<span>self, location='Charger')</span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Member function to return the exact location coordinates of a specific location of the robot based
on path waypoint numbers and row numbers in the two given fields
:param location: The location of the robot in the form of a string. Example: Charger, FBR10, etc.
:return: The location coordinates as a string. Example: [300, 500], [1000, 50], etc.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_location(self, location=&#34;Charger&#34;):
    &#34;&#34;&#34;
    Description
    -----------
    Member function to return the exact location coordinates of a specific location of the robot based
    on path waypoint numbers and row numbers in the two given fields
    :param location: The location of the robot in the form of a string. Example: Charger, FBR10, etc.
    :return: The location coordinates as a string. Example: [300, 500], [1000, 50], etc.
    &#34;&#34;&#34;
    if re.match(r&#39;(\s)*charger(\s)*&#39;, location, re.IGNORECASE):
        return &#34;[charger]&#34;, self.data[&#39;world&#39;][&#39;charger&#39;][&#39;location&#39;]
    elif re.match(r&#39;(\s)*PTH(\s)*\d+&#39;, location, re.IGNORECASE):
        output = (re.findall(r&#39;\d+&#39;, location))
        path_number = int(output[0])
        waypoint_number = int(output[1])
        location_key = [&#34;world&#34;, &#34;paths&#34;, &#34;path-&#34; + str(path_number), &#34;waypoint-&#34; + str(waypoint_number)]
        return &#34;[path-&#34; + str(path_number) + &#34;]&#34;, get_location(self.data, location_key)
    else:
        output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
        location_key = [&#34;world&#34;, &#34;fields&#34;,
                        &#34;field-b&#34; if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE) else &#34;field-a&#34;, &#34;rows&#34;,
                        &#34;row-&#34; + str(output), &#34;location&#34;]
        return &#34;[&#34; + str(location_key[2]) + &#34;]&#34; + &#34;[&#34; + str(location_key[4]) + &#34;]&#34;, get_location(self.data,
                                                                                                 location_key)</code></pre>
</details>
</dd>
<dt id="World.Farm.update_world"><code class="name flex">
<span>def <span class="ident">update_world</span></span>(<span>self, location='FBR8', crop='CARROTS')</span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Member function to plant a crop in the farm file at the desired field and row location
:param location: An encoded name of the field and row location passed in as a string
:param crop: The name of the crop to be planted passed in as a string</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_world(self, location=&#34;FBR8&#34;, crop=&#34;CARROTS&#34;):
    &#34;&#34;&#34;
    Description
    -----------
    Member function to plant a crop in the farm file at the desired field and row location
    :param location: An encoded name of the field and row location passed in as a string
    :param crop: The name of the crop to be planted passed in as a string
    &#34;&#34;&#34;
    if re.match(r&#39;(\s)*FBR(\s)*\d+&#39;, location, re.IGNORECASE):
        output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
        crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-b&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
        update_crops(self.data, crop_key, crop)
    else:
        output = &#34;{0:0=2d}&#34;.format(int((re.findall(r&#39;\d+&#39;, location))[0]))
        crop_key = [&#34;world&#34;, &#34;fields&#34;, &#34;field-a&#34;, &#34;rows&#34;, &#34;row-&#34; + str(output), &#34;crop&#34;]
        update_crops(self.data, crop_key, crop)</code></pre>
</details>
</dd>
<dt id="World.Farm.write_to_world_file"><code class="name flex">
<span>def <span class="ident">write_to_world_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="description">Description</h2>
<p>Member function to write the current farm file to the given json file. The function simply opens the json
file which is initialized by the <strong>init</strong> function and then writes the stored dictionary to the file and
closes it</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_world_file(self):
    &#34;&#34;&#34;
    Description
    -----------
    Member function to write the current farm file to the given json file. The function simply opens the json
    file which is initialized by the __init__ function and then writes the stored dictionary to the file and
    closes it
    &#34;&#34;&#34;
    with open(self.json_path, &#34;w+&#34;) as world_file:
        world_file.write(json.dumps(self.data))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="World.get_location" href="#World.get_location">get_location</a></code></li>
<li><code><a title="World.update_crops" href="#World.update_crops">update_crops</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="World.Farm" href="#World.Farm">Farm</a></code></h4>
<ul class="">
<li><code><a title="World.Farm.decrypt_location" href="#World.Farm.decrypt_location">decrypt_location</a></code></li>
<li><code><a title="World.Farm.update_world" href="#World.Farm.update_world">update_world</a></code></li>
<li><code><a title="World.Farm.write_to_world_file" href="#World.Farm.write_to_world_file">write_to_world_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>